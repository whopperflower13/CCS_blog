function p(t, l) {
  const o = {
    type: "footnotes",
    raw: l,
    rawItems: [],
    items: []
  };
  return {
    name: "footnote",
    level: "block",
    childTokens: ["content"],
    tokenizer(r) {
      t.hasFootnotes || (this.lexer.tokens.push(o), t.tokens = this.lexer.tokens, t.hasFootnotes = !0, o.rawItems = [], o.items = []);
      const e = /^\[\^([^\]\n]+)\]:(?:[ \t]+|[\n]*?|$)([^\n]*?(?:\n|$)(?:\n*?[ ]{4,}[^\n]*)*)/.exec(
        r
      );
      if (e) {
        const [n, i, d = ""] = e;
        let f = d.split(`
`).reduce((c, s) => c + `
` + s.replace(/^(?:[ ]{4}|[\t])/, ""), "");
        const u = f.trimEnd().split(`
`).pop();
        f += // add lines after list, blockquote, codefence, and table
        u && /^[ \t]*?[>\-*][ ]|[`]{3,}$|^[ \t]*?[|].+[|]$/.test(u) ? `

` : "";
        const a = {
          type: "footnote",
          raw: n,
          label: i,
          refs: [],
          content: this.lexer.blockTokens(f)
        };
        return o.rawItems.push(a), a;
      }
    },
    renderer() {
      return "";
    }
  };
}
function m(t, l = !1) {
  let o = 0;
  return {
    name: "footnoteRef",
    level: "inline",
    tokenizer(r) {
      const e = /^\[\^([^\]\n]+)\]/.exec(r);
      if (e) {
        const [n, i] = e, d = this.lexer.tokens[0], f = d.rawItems.filter(
          (s) => s.label === i
        );
        if (!f.length) return;
        const u = f[0], a = d.items.filter((s) => s.label === i)[0], c = {
          type: "footnoteRef",
          raw: n,
          id: "",
          label: i
        };
        return a ? (c.id = a.refs[0].id, a.refs.push(c)) : (o++, c.id = String(o), u.refs.push(c), d.items.push(u)), c;
      }
    },
    renderer({ id: r, label: e }) {
      o = 0;
      const n = encodeURIComponent(e);
      return `<sup><a id="${t}ref-${n}" href="#${t + n}" data-${t}ref aria-describedby="${t}label">${l ? `[${r}]` : r}</a></sup>`;
    }
  };
}
function $(t) {
  return {
    name: "footnotes",
    renderer({ raw: l, items: o = [] }) {
      if (o.length === 0) return "";
      const r = o.reduce(
        (n, { label: i, content: d, refs: f }) => {
          const u = encodeURIComponent(i), a = this.parser.parse(d).trimEnd(), c = a.endsWith("</p>");
          let s = `<li id="${t + u}">
`;
          return s += c ? a.replace(/<\/p>$/, "") : a, f.forEach((k, h) => {
            s += ` <a href="#${t}ref-${u}" data-${t}backref aria-label="Back to reference ${i}">${h > 0 ? `↩<sup>${h + 1}</sup>` : "↩"}</a>`;
          }), s += c ? `</p>
` : `
`, s += `</li>
`, n + s;
        },
        ""
      );
      let e = `<section class="footnotes" data-footnotes>
`;
      return e += `<h2 id="${t}label" class="sr-only">${l.trimEnd()}</h2>
`, e += `<ol>
${r}</ol>
`, e += `</section>
`, e;
    }
  };
}
function b(t = {}) {
  const {
    prefixId: l = "footnote-",
    description: o = "Footnotes",
    refMarkers: r
  } = t, e = { hasFootnotes: !1, tokens: [] };
  return {
    extensions: [
      p(e, o),
      m(l, r),
      $(l)
    ],
    walkTokens(n) {
      n.type === "footnotes" && e.tokens.indexOf(n) === 0 && n.items.length && (e.tokens[0] = { type: "space", raw: "" }, e.tokens.push(n)), e.hasFootnotes && (e.hasFootnotes = !1);
    }
  };
}
export {
  b as default
};
